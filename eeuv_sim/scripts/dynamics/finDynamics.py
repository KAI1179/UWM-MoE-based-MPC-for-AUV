#!/usr/bin/python3

"""
Simplified fin dynamic model

@author: Walid Remmas
@contact: walid.remmas@taltech.ee
"""

import rclpy
from rclpy.node import Node

import numpy as np


class FinDynamics():
    """
    Class to compute and simulate the dynamics of paddling fins.
    """

    def __init__(self, dynamics_parameters):
        """
            self:
            dynamics_parameters: dictionary variable containg fin dynamics params
        """
        self.k_thrust = dynamics_parameters["simplified"]["k_thrust"]
        self.k_lateral = dynamics_parameters["simplified"]["k_lateral"]

        self.finMappingDirection =  dynamics_parameters["finMapDirection"]
        self.initialState =  dynamics_parameters["initialState"]
        self.surgeMap = dynamics_parameters["surgeMap"]
        self.swayMap = dynamics_parameters["swayMap"]
        self.heaveMap = dynamics_parameters["heaveMap"]
        self.rollMap = dynamics_parameters["rollMap"]
        self.pitchMap = dynamics_parameters["pitchMap"]
        self.yawMap = dynamics_parameters["yawMap"]

        alpha_mount = dynamics_parameters["fin_mounting_angle"]
        self.alpha_mount_cos = np.cos(np.deg2rad(alpha_mount))
        self.alpha_mount_sin = np.sin(np.deg2rad(alpha_mount))

        self.finMomentArm = dynamics_parameters["finMomentArm"]

        self.FxFins = np.zeros(4)
        self.FyFins = np.zeros(4)
        self.FzFins = np.zeros(4)

        self.TxFins = np.zeros(4)
        self.TyFins = np.zeros(4)
        self.TzFins = np.zeros(4)

    def getWrench(self, finsPosition, finsVelocity, finsAcceleration):
        """
        Function to convert the forces generated by the fins into Forces
        and Torques in body frame
        @param: self
        @result: publishes wrench message of torques.
        """
        position = np.array(finsPosition)
        velocity = np.array(finsVelocity)
        acceleration = np.array(finsAcceleration)

        Facc = self.k_thrust * acceleration**2
        Flateral = self.k_lateral * velocity

        # Convert force vector to fin frame
        horizontalForceFinFrame = Facc * np.cos(position) - Flateral * np.sin(position)
        verticalForceFinFrame = Facc * np.sin(position) + Flateral * np.cos(position)

        # Convert forces vectors in fin frame to body frame
        FxFins = horizontalForceFinFrame * self.alpha_mount_cos * self.surgeMap
        FyFins = horizontalForceFinFrame * self.alpha_mount_sin * self.swayMap
        FzFins = verticalForceFinFrame * self.heaveMap

        # Debug variables
        self.FxFins = FxFins
        self.FyFins = FyFins
        self.FzFins = FzFins

        self.TxFins = self.finMomentArm[0] * verticalForceFinFrame * self.rollMap
        self.TyFins = self.finMomentArm[1] * verticalForceFinFrame * self.pitchMap
        self.TzFins = self.finMomentArm[2] * horizontalForceFinFrame * self.yawMap

        # Sum forces and torques
        forceXBody = sum(FxFins)
        forceYBody = sum(FyFins)
        forceZBody = sum(FzFins)

        torqueX = sum(self.finMomentArm[0] * verticalForceFinFrame * self.rollMap)
        torqueY = sum(self.finMomentArm[1] * verticalForceFinFrame * self.pitchMap)
        torqueZ = sum(self.finMomentArm[2] * horizontalForceFinFrame * self.yawMap)


        wrench = [forceXBody, forceYBody, forceZBody, torqueX, torqueY, torqueZ]

        return wrench

class FinDynamicsLiftDrag():
    def __init__(self, dynamics_parameters):
        """
        Initialize fins with predefined fin parameters in variable dynamics_parameters
        @param: self
        @param: dt - (float) integration step size [in seconds]
        @param: initial_fin_orientation - (float 4x1) initial fin orientations [in rads]
        @param: k_thrust - (float) coefficient for generated thrust
        @param: k_lateral - (float) coefficient for generated lateral thrust
        @param: debug - (bool) debugging allowed when True (using icecream library)
        """

        self.initialState = np.array(dynamics_parameters["initialState"])

        self.waterDensity = dynamics_parameters['liftAndDrag']['water_density']
        self.cd = dynamics_parameters['liftAndDrag']['cd']
        self.cl = dynamics_parameters['liftAndDrag']['cl']
        self.finArea = dynamics_parameters['liftAndDrag']['finArea']
        self.rc = dynamics_parameters['liftAndDrag']['rc']
        self.finLength = dynamics_parameters['liftAndDrag']['finLength']

        self.finMappingDirection = dynamics_parameters['finMapDirection']
        self.heaveMap = dynamics_parameters['heaveMap']
        self.swayMap = dynamics_parameters['swayMap']
        self.rollMap = dynamics_parameters['rollMap']
        self.pitchMap = dynamics_parameters['pitchMap']
        self.yawMap = dynamics_parameters['yawMap']

        alpha_mount = dynamics_parameters['fin_mounting_angle']
        self.alpha_mount_cos = np.cos(np.deg2rad(alpha_mount))
        self.alpha_mount_sin = np.array(
            [x * np.sin(np.deg2rad(alpha_mount)) for x in self.swayMap])

        self.finMomentArm = dynamics_parameters["finMomentArm"]



    def getInflow(self, amplitude, frequency, zero_direction, phaseOffset):
        """
        Function to compute the direction and angle of the flow velocity
        over each fin, induced by either the robot movement, or the
        fluid influx due to the fluid components pushed away by the fin
        during each stroke. The calculation that uses body velocity
        uses the explicit assumption that cross flow (y-direction in
        fin frame) over the fin is neglected. TODO: combine both fluid
        flow sources.
        @param: self
        @param: amplitude - amplitude of the oscillating fin [4x1]
        @param: frequency - frequency of the osciallating fin [4x1]
        @param: zero_direction - zero_direction of the oscillating fin [4x1]
        @result: returns velocity and angle of fluid flow over fin caused
                 by oscillation induced water flow behind the fin movement
                 TODO: integrate flow induced by motion of the robot
        """
        # rollMap = self.rollMap
        # pitchMap = self.pitchMap
        # yawMap = self.yawMap
        # swayMap = self.swayMap

        l_fin = self.finLength
        vel_in = np.zeros(4)
        alpha_in = np.zeros(4)
        for idx in range(0, 4):
            if frequency[idx] != 0.0 and amplitude[idx] != 0.0:
                U_in_fin = l_fin * amplitude[idx] / \
                    (1.0 / frequency[idx] * np.sin(amplitude[idx] / 2.0))
            else:
                U_in_fin = 0.0

            alpha_in[idx] = self.initialState[idx] + zero_direction[idx]\
                                     * self.finMappingDirection[idx]
            vel_in[idx] = U_in_fin

        return vel_in, alpha_in

    def getWrenches(
            self, finPositions, finVelocities, amplitude, frequency,
            zeroDirection, phaseOffset):
        """
        get amount of wrenches generated by the fins in body frame
        @param: self
        @param: finPositions - (4x1) fins' positions  [in rads]
        @param: finVelocities - (4x1) fins' velocities  [in rads/s]
        @param: finsAccelerations - (4x1) fins' velocities  [in rads/s^2]

        @result: returns the generated forces in body frame (6x1)
        """

        theta = np.array(finPositions)
        velocity = np.array(finVelocities)

        ### get inflow velocity and its components ###
        vel_in, alpha_in = self.getInflow(amplitude, frequency, zeroDirection, phaseOffset)
        vel_in_x = vel_in * np.cos(alpha_in)
        vel_in_y = vel_in * np.sin(alpha_in)

        ### get normal velocity (due to motor rotation) and its components ###
        vel_normal = -self.rc * velocity
        theta_normal = np.pi / 2.0 - theta
        vel_normal_x = vel_normal * np.cos(theta_normal)
        vel_normal_y = vel_normal * np.sin(theta_normal)

        ### calculate magnitude and angle of attack of velocity vector
        # over fin from inflow velocity and normal velocity ###
        vel_mag = np.sqrt((vel_in_x + vel_normal_x)**2 +
                          (-vel_in_y + vel_normal_y)**2)
        vel_ang = np.arctan2(-vel_in_y + vel_normal_y, vel_in_x + vel_normal_x)

        alpha_aoa = vel_ang + theta   # angle of attack

        ### calculate lift and drag for each fin ###
        Af = self.finArea
        rho = self.waterDensity
        cd = self.cd
        cl = self.cl
        fin_lift = 0.5 * cl * rho * Af * vel_mag**2.0 * np.sin(2.0 * alpha_aoa)
        fin_drag = 0.5 * cd * rho * Af * vel_mag**2.0 * (1.0 - np.cos(2.0 * alpha_aoa))

        ### map lift and drag forces to fin motor frame ###
        hForce = np.zeros(4)
        vForce = np.zeros(4)
        for i in range(0, 4):
            vForce[i] = -fin_lift[i] * np.cos(vel_ang[i]) - \
                             fin_drag[i] * np.sin(vel_ang[i])
            hForce[i] = fin_drag[i] * np.cos(vel_ang[i]) - \
                             fin_lift[i] * np.sin(vel_ang[i])

        ### Convert forces vectors in fin motor frame to body frame ###
        FxFins = hForce * self.alpha_mount_cos
        FyFins = hForce * self.alpha_mount_sin
        FzFins = vForce * self.heaveMap

        ### compute wrenches ###
        forceXBody = sum(FxFins)
        forceYBody = sum(FyFins)
        forceZBody = sum(FzFins)
        torqueX = sum(self.finMomentArm[0] * vForce * self.rollMap)
        torqueY = sum(self.finMomentArm[1] * vForce * self.pitchMap)
        torqueZ = sum(self.finMomentArm[2] * hForce * self.yawMap)

        wrenches = [forceXBody, forceYBody, forceZBody, torqueX, torqueY, torqueZ]

        return wrenches